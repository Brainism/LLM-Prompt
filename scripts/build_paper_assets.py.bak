import os
import sys
import re
import json
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

ROOT = r"C:\Project\LLM"
SRC = os.path.join(ROOT, "aggregated_metrics_fixed_with_chrf_rouge.csv")
OUT_FIG_DIR = os.path.join(ROOT, "docs", "paper", "figs")
OUT_TABLE_DIR = os.path.join(ROOT, "docs", "paper", "tables")
os.makedirs(OUT_FIG_DIR, exist_ok=True)
os.makedirs(OUT_TABLE_DIR, exist_ok=True)

B = 10000
RNG_SEED = 1234

def safe_read_csv(path):
    try:
        return pd.read_csv(path, encoding="utf-8-sig")
    except Exception:
        try:
            return pd.read_csv(path, encoding="latin1")
        except Exception as e:
            raise RuntimeError(f"Failed to read CSV '{path}': {e}")

def table_image(df_table, fname, title, outdir):
    outpath = os.path.join(outdir, fname)
    if df_table is None or df_table.empty:
        plt.figure(figsize=(6,1.8))
        plt.axis("off")
        plt.text(0.5, 0.5, "No data", ha="center", va="center")
        plt.tight_layout()
        plt.savefig(outpath, dpi=300)
        plt.close()
        return outpath

    cell_text = []
    for row in df_table.values:
        row_conv = []
        for v in row:
            if pd.isna(v):
                row_conv.append("")
            elif isinstance(v, (int, np.integer)):
                row_conv.append(str(int(v)))
            elif isinstance(v, (float, np.floating)):
                row_conv.append(f"{v:.3f}")
            else:
                row_conv.append(str(v))
        cell_text.append(row_conv)

    plt.figure(figsize=(12, 4.8))
    plt.axis("off")
    plt.title(title, fontsize=14, pad=10)
    tbl = plt.table(cellText=cell_text, colLabels=df_table.columns.tolist(), loc="center")
    tbl.auto_set_font_size(False)
    tbl.set_fontsize(9)
    tbl.scale(1, 1.2)
    plt.tight_layout()
    plt.savefig(outpath, dpi=300)
    plt.close()
    return outpath

def pick_mode_mapping(modes):
    low = [m.lower() for m in modes]
    instr_keywords = ['instr','instruct','instruction','instructed','instructive','instructs']
    base_keywords = ['general','base','baseline','orig','original','default']
    instr_choice = None
    base_choice = None
    for k in instr_keywords:
        for m,lm in zip(modes, low):
            if k in lm:
                instr_choice = m
                break
        if instr_choice:
            break
    for k in base_keywords:
        for m,lm in zip(modes, low):
            if k in lm:
                base_choice = m
                break
        if base_choice:
            break
    if instr_choice and base_choice and instr_choice != base_choice:
        return base_choice, instr_choice
    if len(modes) == 2:
        a,b = modes[0], modes[1]
        if any(k in a.lower() for k in instr_keywords) and not any(k in b.lower() for k in instr_keywords):
            return b, a
        if any(k in b.lower() for k in instr_keywords) and not any(k in a.lower() for k in instr_keywords):
            return a, b
        return a, b
    return None, None

def pivot_long_to_wide(df, metric):
    if 'id' not in df.columns or 'mode' not in df.columns:
        return None
    pivot = df.groupby(['id','mode'], dropna=False)[metric].mean().reset_index()
    try:
        wide = pivot.pivot(index='id', columns='mode', values=metric)
    except Exception as e:
        raise RuntimeError(f"Pivot failure for metric '{metric}': {e}")
    wide = wide.reset_index()
    return wide

def detect_and_prepare(df):
    cols = list(df.columns)
    if 'base' in cols and 'instr' in cols:
        return df.copy()

    if 'mode' in cols:
        metric_priority = ['bleu','bleu_score','sacrebleu','score','metric']
        metric = None
        for m in metric_priority:
            if m in cols:
                metric = m; break
        if metric is None:
            numeric_cols = [c for c in cols if c not in ('id','mode') and pd.api.types.is_numeric_dtype(df[c])]
            if numeric_cols:
                metric = numeric_cols[0]
            else:
                for c in cols:
                    if 'bleu' in c.lower() or 'score' in c.lower():
                        metric = c; break
        if metric is None:
            raise RuntimeError(f"Could not find a metric column to pivot. Available columns: {cols}")

        wide = pivot_long_to_wide(df, metric)
        if wide is None or wide.shape[1] < 3:
            raise RuntimeError(f"Pivot produced insufficient columns. pivot shape: {None if wide is None else wide.shape}")

        modes = [c for c in wide.columns.tolist() if c != 'id']
        base_mode, instr_mode = pick_mode_mapping(modes)
        if base_mode is None or instr_mode is None:
            raise RuntimeError(f"Could not automatically map modes to base/instr. Detected modes: {modes}")

        df_out = wide.rename(columns={base_mode: 'base', instr_mode: 'instr'}).copy()

        extras = ['chrf','rouge_l','rougeL','rouge-l','rouge_l_f1']
        for extra in extras:
            if extra in df.columns:
                try:
                    extra_wide = pivot_long_to_wide(df, extra)
                    if extra_wide is not None and 'id' in extra_wide.columns:
                        rename_map = {}
                        for c in extra_wide.columns:
                            if c == 'id':
                                continue
                            rename_map[c] = f"{extra}_{c}"
                        extra_wide = extra_wide.rename(columns=rename_map)
                        df_out = df_out.merge(extra_wide, on='id', how='left')
                except Exception:
                    pass

        return df_out

    raise RuntimeError("Data format not recognized (no 'mode' column and no 'base'/'instr' columns).")

def main():
    if not os.path.exists(SRC):
        print("ERROR: missing source:", SRC); sys.exit(1)

    df = safe_read_csv(SRC)
    print("Loaded", SRC, "rows=", len(df))
    print("Columns detected:", list(df.columns))

    df.columns = [c.replace('-', '_') for c in df.columns]

    try:
        prepared = detect_and_prepare(df)
    except Exception as e:
        print("ERROR:", e)
        sys.exit(1)

    if not ('base' in prepared.columns and 'instr' in prepared.columns):
        print("ERROR: prepared data missing 'base'/'instr' columns. Prepared columns:", list(prepared.columns))
        sys.exit(1)

    prepared['base'] = pd.to_numeric(prepared['base'], errors='coerce')
    prepared['instr'] = pd.to_numeric(prepared['instr'], errors='coerce')
    prepared['delta'] = prepared['instr'] - prepared['base']
    delta = prepared['delta'].dropna().values
    n = len(delta)
    if n == 0:
        print("ERROR: no valid delta values after preparation"); sys.exit(1)

    rng = np.random.default_rng(RNG_SEED)
    print(f"Starting bootstrap B={B} (n={n}) ... this may take time")
    boots = []
    for _ in range(B):
        idx = rng.integers(0, n, n)
        boots.append(delta[idx].mean())
    boots = np.array(boots)
    ci_low, ci_high = np.percentile(boots, [2.5, 97.5])
    delta_mean = float(delta.mean())

    stats = {"n": int(n), "B": int(B), "delta_mean": float(delta_mean), "ci95": [float(ci_low), float(ci_high)]}
    with open(os.path.join(OUT_FIG_DIR, "bleu_stats.json"), "w", encoding="utf-8") as fh:
        json.dump(stats, fh, ensure_ascii=False, indent=2)
    print("Bootstrap done. mean=", delta_mean, "95%CI=", (ci_low, ci_high))

    plt.figure(figsize=(6,6))
    plt.scatter(prepared['base'], prepared['instr'], s=36)
    mmin = min(prepared['base'].min(), prepared['instr'].min())
    mmax = max(prepared['base'].max(), prepared['instr'].max())
    plt.plot([mmin, mmax], [mmin, mmax], "--", linewidth=1)
    arr_base = prepared['base'].to_numpy(dtype=float)
    arr_instr = prepared['instr'].to_numpy(dtype=float)
    mask = ~(np.isnan(arr_base) | np.isnan(arr_instr))
    r = float(np.corrcoef(arr_base[mask], arr_instr[mask])[0,1]) if mask.sum() > 0 else float('nan')
    plt.title(f"Per-item (n={n}, r={r:.3f})")
    plt.xlabel("Base"); plt.ylabel("Instructed")
    plt.tight_layout()
    plt.savefig(os.path.join(OUT_FIG_DIR, "bleu_scatter_300dpi.png"), dpi=300)
    plt.close()

    plt.figure(figsize=(7,5))
    plt.boxplot([prepared['base'].dropna(), prepared['instr'].dropna()], labels=["Base","Instructed"])
    plt.title(f"Paired (n={n})  ?={delta_mean:.3f}")
    plt.ylabel("Score")
    plt.tight_layout()
    plt.savefig(os.path.join(OUT_FIG_DIR, "bleu_boxplot_300dpi.png"), dpi=300)
    plt.close()

    plt.figure(figsize=(8,4.5))
    plt.hist(boots, bins=40)
    plt.axvline(0, color="k", linestyle="--")
    plt.axvline(delta_mean, color="r", linestyle="-")
    plt.title(f"Bootstrap ? (mean={delta_mean:.3f}, 95% CI=[{ci_low:.3f},{ci_high:.3f}], n={n}, B={B})")
    plt.xlabel("? (instr - base)")
    plt.tight_layout()
    plt.savefig(os.path.join(OUT_FIG_DIR, "bleu_bootstrap_delta_300dpi.png"), dpi=300)
    plt.close()

    safe_cols = [c for c in ["id","base","instr","delta","chrf","rouge_l","rougeL"] if c in prepared.columns]
    df_show = prepared[safe_cols].sort_values("delta", ascending=False)
    top10 = df_show.head(10)
    bot10 = df_show.tail(10)
    top10.to_csv(os.path.join(OUT_TABLE_DIR, "top10_delta.csv"), index=False, encoding="utf-8-sig")
    bot10.to_csv(os.path.join(OUT_TABLE_DIR, "bottom10_delta.csv"), index=False, encoding="utf-8-sig")
    table_image(top10, "top10_delta_300dpi.png", "Top 10 ?", OUT_FIG_DIR)
    table_image(bot10, "bottom10_delta_300dpi.png", "Bottom 10 ?", OUT_FIG_DIR)

    print("All figures and tables saved to:", OUT_FIG_DIR, OUT_TABLE_DIR)

if __name__ == "__main__":
    main()
